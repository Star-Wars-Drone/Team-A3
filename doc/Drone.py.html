<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{color:#1155cc;text-decoration:underline}.c5{color:inherit;text-decoration:inherit}.c2{height:11pt}.c4{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c7"><p class="c0"><span class="c3">This readme is for the Drone.py file that contains the Drone class.</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">This class uses dronekit to send MAVlink commands to Ardupilot</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span>Dronekit:</span><span class="c4">&nbsp;</span><span class="c6"><a class="c5" href="https://www.google.com/url?q=http://python.dronekit.io/&amp;sa=D&amp;ust=1493508321152000&amp;usg=AFQjCNFQQux88R1DjP4Pder1_rlGFF0XjQ">http://python.dronekit.io/</a></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">__init__()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span>This function connects to the local loop back on the mavproxy server, switches the starting mode to GUIDED, sets the vehicle ground speed, and finally calls the </span><span class="c4">run()</span><span class="c1">&nbsp;function. </span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">This function also has a try, except clause inside of it to detect when the user inputs a KeyboardInterrupt. This allows us to safely stop the application and call the cleanup code.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">__del__()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span>This function just calls </span><span class="c4">self.vehicle.close() </span><span class="c1">which is the dronekit function that cleans up and deletes the vehicle object.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">move_to_altitude(altitude)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">THIS FUNCTION WAS NOT USED IN THE FINAL DEMO.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">This function takes in an altitude and moves the drone to that altitude. The drone must be in the air when this is called.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">take_off(altitude)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function waits for pre-arm checks, arms the drone, and takes off to the altitude that was given. Altitude is in meters. This function also blocks until the altitude is reached.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">land()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function switches the drone into LAND mode then just waits.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">condition_yaw(heading, relative=False)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function yaws the drone CW at the default speed. It sends the CONDITION_YAW command to the drone. The drone must be in AUTO mode to use this function. </span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>Setting </span><span class="c4">relative </span><span>to true means that the drone will yaw relative to the direction of travel, and setting </span><span class="c4">relative </span><span class="c1">to false means the drone yaws at an absolute angle</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">send_ned_velocity(velocity_x, velocity_y, velocity_z, duration)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">THIS FUNCTION WAS NOT USED IN THE FINAL DEMO</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function allows you to give the drone a velocity vector via a North, East, Down coordinate. It sends the SET_POSITION_TARGET_LOCAL_NED message to the drone. This function wasn&rsquo;t used because there is a way to give this message distance instead of velocity</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">take_off_and_land()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">THIS FUNCTION WAS NOT USED IN THE FINAL DEMO</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">This function is usually called just to make sure the drone is flying well. It tells the drone to takeoff, fly to 25m, and then land.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">read_waypoints(filename)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function simply reads in the waypoints from the waypoints.txt file and returns the number of waypoints that were read in.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">If you would like to use this function, the text file must be formatted like this.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">35.767807,-78.663522,5</span></p><p class="c0"><span class="c1">Lat &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lon &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Alt</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Each waypoint must be placed on a new line. </span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">get_distance_metres(aLocation1,aLocation2)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function calculates and returns the distance between two locations.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">fly_to_waypoint(waypoint)</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">This function flies to the waypoint that is given. The waypoint must be given as a dronekit Location object. This function will print out the distance that the drone is from the target. It also blocks until the drone reaches the location.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span>&nbsp;</span><span class="c3">goto_position_target_local_ned(north, east, down)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span>This is the function that we used to move along the vector that is given to the navigation code from the image processing code. It uses the SET_POSITION_TARGET_LOCAL_NED message. </span><span class="c4">The important thing to note here is that the 4th parameter that was used was MAV_FRAME_BODY_OFFSET_NED.</span><span class="c1">&nbsp;This parameter makes the drone the origin of the north, east, down coordinate system. </span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">set_attitude_target(roll,pitch,yaw)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">THIS FUNCTION WAS NOT USED IN THE FINAL DEMO</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">This function just sends the SET_ATTITUDE_TARGET message. This function hasn&rsquo;t been tested outside of SITL. Use at your own risk.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">clean_exit()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function is what is called when a KeyboardInterrupt. It tells the drone to land and cleans up the vehicle object. Then the function exits the program</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">rotate_and_check_360_div_by_n(n)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function divides 360 by n then rotates by that angle until it has rotated 360 degrees</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">kill()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This is the function that checks the LIDAR to see if the balloon is in range then fires the laser. After the laser is fired, it asks the image processing code if the balloon is still there. It returns True if the balloon was killed and False if it was not killed.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">update_vector(bf)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function asks the image processing code to update the vector to the balloon. The input is the BalloonFinder object. It also returns the vector.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">rotate_and_check_for_balloon(n,bf)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span>This function is exactly like </span><span class="c4">rotate_and_check_360_div_by_n(n)</span><span class="c1">&nbsp;except it also asks the camera if the balloon is there after it rotates. Once it finds the balloon, it returns the distance vector. The function takes in the number of division and the BalloonFinder object.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">test_check_center(bf)</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">THIS FUNCTION WAS NOT USED IN THE FINAL DEMO</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">This function checks if the balloon is centered in frame. This was used as a pre-check to fire the laser. The final check was with the LIDAR. This function takes in the BalloonFinder class.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c3">run()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span>This is where all the magic comes together. This is the run function that popped the red balloon on demo day.</span></p></body></html>